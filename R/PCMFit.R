# Copyright 2018 Venelin Mitov
#
# This file is part of PCMFit
#
# PCMFit is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# PCMFit is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PCMFit.  If not, see <http://www.gnu.org/licenses/>.

#' Fitting a PCM model to a given tree and data
#' @inheritParams PCMBase::PCMLik
#' @param positiveValueGuard a real number (not necessarily positive) used during
#' the fit as a threshold for highly positive but likely incorrect log-likelihood
#' values. This argument is set to \code{Inf} by default and should be used only
#' as a last escape. The recommended way to of preventing such numerical errors
#' is by setting more stringent values for the runtime options
#' \code{PCMBase.Threshold.EV} and \code{PCMBase.Threshold.SV} (see
#' \code{\link{PCMOptions}}).
#' @param argsPCMParamLowerLimit,argsPCMParamUpperLimit named lists with
#' arguments passed to the functions \code{\link{PCMParamLowerLimit}} and
#' \code{\link{PCMParamUpperLimit}}, respectively. Default: \code{NULL}.
#' @param matParInit a matrix of any number of rows and p columns where, p is
#' the number of variable numerical parameters in the model
#' (equal to \code{PCMParamCount(model)}). Each row of this matrix specifies a
#' suggested starting location for the optim L-BFGS-B run. Default: NULL,
#' meaning that the initial parameters are to be chosen at random and/or using
#' calls to \code{\link{GuessInitVecParams}} function.
#' @param numRunifInitVecParams,numGuessInitVecParams integers specifying how
#' many parameter vectors should be drawn from a uniform distribution between
#' \code{PCMParamLowerLimit(model)} and \code{PCMParamUpplerLimit(model)}, and
#' how many parameter vectors should be generated by jittering the resulting
#' vector from a  call to \code{\link{GuessInitVecParams}}. Before starting the
#' optimization the model likelihood is evaluated at each of these vectors and
#' the top \code{numCallsOptim} vectors are chosen for starting locations for
#' optimization. The default settings are
#' \code{numRunifInitVecParams = if( is.null(matParInit) ) 1000L else 0L} and
#' \code{numGuessInitVecParams = if( is.null(matParInit) ) 100L else 0L}.
#' @param numCallsOptim integer specifying the maximum number of calls to
#' \code{\link{optim}} function. Default: 10. Note that this parameter would be
#' overwritten by a smaller \code{nrow(matParInit)} (if \code{matParInit} is
#' specified) or by a smaller number of generated initial parameter vectors that
#' satisfy the parameter limits (see also the arguments
#' \code{numRunifInitVecParams,numGuessInitVecParams} and
#' \code{argsPCMParamLowerLimit}, \code{argsPCMParamUpperLimit}).
#' @param control a list passed as control argument to \code{\link{optim}}.
#' Default: NULL.
#' @param doParallel logical indicating if optim calls should be executed in
#' parallel using the \code{foreach() \%dopar\% \{\}} construct. Default: FALSE.
#' @param verbose logical indicating if information messages should be printed
#' to the console while running. Default: FALSE.
#' @return an object of class PCMFit
#' @importFrom PCMBase PCMCreateLikelihood PCMInfo PCMParamCount PCMParamGetShortVector PCMParamLoadOrStore PCMParamLowerLimit PCMParamUpperLimit PCMParamRandomVecParams PCMOptions
#' @importFrom foreach foreach %do% %dopar%
#' @seealso \code{\link{PCMOptions}}
#' @export
PCMFit <- function(
  X, tree, model,
  SE = matrix(0.0, PCMNumTraits(model), PCMTreeNumTips(tree)),
  metaI = PCMInfo(X, tree, model, SE),
  positiveValueGuard = Inf,
  argsPCMParamLowerLimit = NULL,
  argsPCMParamUpperLimit = NULL,
  matParInit = NULL,
  numRunifInitVecParams = if( is.null(matParInit) ) 1000L else 0L,
  numGuessInitVecParams = if( is.null(matParInit) ) 100L else 0L,
  numCallsOptim = 10L,
  control = NULL,
  doParallel = FALSE,
  verbose = FALSE) {

  lowerModel <- do.call(PCMParamLowerLimit, c(list(model), argsPCMParamLowerLimit))
  lowerVecParams <- PCMParamGetShortVector(lowerModel)

  upperModel <- do.call(PCMParamUpperLimit, c(list(model), argsPCMParamUpperLimit))
  upperVecParams <- PCMParamGetShortVector(upperModel)


  matParamsModel <- matrix(
    PCMParamGetShortVector(
      model, k = PCMNumTraits(model), R = PCMNumRegimes(model)), nrow = 1L)

  if(verbose) {
    cat("Generating", numRunifInitVecParams, "random init vectors...\n")
  }
  matParInitRunif <- PCMParamRandomVecParams(
    o = model,
    k = PCMNumTraits(model),
    R = PCMNumRegimes(model),
    n = numRunifInitVecParams,
    argsPCMParamLowerLimit = argsPCMParamLowerLimit,
    argsPCMParamUpperLimit = argsPCMParamUpperLimit
  )
  if(verbose) {
    cat("Generating", numGuessInitVecParams,
        "guessed init vectors with random jittering for ",
        numGuessInitVecParams - 1L, "of them...\n")
  }
  matParInitGuess <- GuessInitVecParams(
    o = model,
    k = PCMNumTraits(model),
    R = PCMNumRegimes(model),
    n = numGuessInitVecParams,
    argsPCMParamLowerLimit = argsPCMParamLowerLimit,
    argsPCMParamUpperLimit = argsPCMParamUpperLimit,
    X = X, tree = tree, SE = SE, varyParams = TRUE)

  matParInit <- rbind(
    matParInit,
    matParamsModel,
    matParInitRunif,
    matParInitGuess)

  if(verbose) {
    cat("Enforcing boundaries on init parameter vectors...\n")
  }
  EnforceBounds(matParInit, lowerVecParams, upperVecParams)

  if(nrow(matParInit) == 0L) {
    stop(
      paste(
        "In a call to PCMFit matParInit was empty. This can happen if you",
        "used only GuessInitVecParams to generate matParInit and all generated",
        "parameters were out of range. Consider using PCMParamRandomVecParams",
        "as well. "))
  }

  if(nrow(matParInit) > numCallsOptim) {
    if(verbose) {
      cat(
        "Evaluating likelihood at", nrow(matParInit), "parameter vectors...\n")
    }

    `%op%` <- if(isTRUE(doParallel) ||
                 (is.numeric(doParallel) && doParallel > 1)) `%dopar%` else `%do%`

    chunk <- function(x,n) split(x, cut(seq_along(x), n, labels = FALSE))

    valParInitOptim <- foreach(
      is = chunk(seq_len(nrow(matParInit)), 8L), .combine = c) %op% {

        lik <- PCMCreateLikelihood(
          X = X, tree = tree, model = model, SE = SE,
          metaI = if(is.function(metaI)) {
            metaI(X = X, tree = tree, model = model, SE = SE)
          } else {
            metaI
          },
          positiveValueGuard = positiveValueGuard)

        sapply(is, function(i) lik(matParInit[i,]))
      }

    topVal <- order(valParInitOptim, decreasing = TRUE)[seq_len(numCallsOptim)]
    matParInit <- matParInit[topVal,, drop=FALSE]

    if(verbose) {
      cat(
        "Taking the top-", numCallsOptim,
        " parameter combinations sorted by decreasing log-likelihood value: ",
        toString(round(valParInitOptim[topVal], 2)), ".\n")
    }
  }

  res <- as.list(environment())
  # These objects tend to be very big. the lik function and the metaI object
  # can be recreated.
  res$lik <- res$matParInit <-
    res$matParInitRunif <- res$matParInitGuess <-
    res$matParInitGuessVaryParams <- NULL

  res$PCMOptions <- PCMOptions()

  res <- c(
    res,
    runOptim(
      X = X, tree = tree, model = model, SE = SE,
      metaI = metaI,
      positiveValueGuard = positiveValueGuard,
      parLower = lowerVecParams,
      parUpper = upperVecParams,
      matParInit = matParInit,
      control = control,
      doParallel = doParallel,
      verbose = verbose))

  if(!is.null(res$Optim)) {
    par <- res$Optim$par
    res$modelOptim <- model
    PCMParamLoadOrStore(res$modelOptim, vecParams = par, offset = 0, load = TRUE)
    res$logLikOptim <- res$Optim$value

  } else {
    res$modelOptim <- NULL
    res$logLikOptim <- as.double(PCMOptions()$PCMBase.Value.NA)
  }

  class(res) <- c("PCMFit", class(res))
  res
}

#'@export
RetrieveBestModel <- function(fit) {
  if(is.PCMFit(fit)) {
    model <- fit$modelOptim
    attr(model, "tree") <- fit$tree
    attr(model, "X") <- fit$X
    attr(model, "SE") <- fit$SE
  } else {
    model <- NULL
  }
  model
}


#' @export
is.PCMFit <- function(object) {
  inherits(object, "PCMFit")
}

#' @importFrom PCMBase PCMOptions PCMTreeNumTips
#' @export
logLik.PCMFit <- function(object, ...) {
  if(!is.PCMFit(object)) {
    stop("object must inherit from class PCMFit.")
  }

  value <- as.double(PCMOptions()$PCMBase.Value.NA)

  if(!is.null(object$modelOptim)) {
    value <- object$logLikOptim
  }

  attr(value, "df") <- PCMParamCount(object$model,
                                     countRegimeChanges = TRUE,
                                     countModelTypes = TRUE)
  attr(value, "nobs") <- PCMTreeNumTips(object$tree)

  value
}

#' @importFrom PCMBase PCMGetVecParamsRegimesAndModels
#' @export
coef.PCMFit <- function(object, ...) {
  if(!is.PCMFit(object)) {
    stop("object must inherit from class PCMFit.")
  }

  model <- object$model

  if(!is.null(object$modelOptim)) {
    model <- object$modelOptim
  }

  par <- PCMGetVecParamsRegimesAndModels(model, object$tree, ...)
  c(par, numParam = PCMParamCount(model))
}

# A utility function used to save the maximum point of f (used as wrapper for
# likelihod-functions).
memoiseMax <- function(f, par, memo, verbose) {
  countMemo <- mget('count', envir = memo, ifnotfound = list(0))$count
  valMemo <- mget('val', envir = memo, ifnotfound = list(-Inf))$val
  valPrev <- mget('valPrev', envir = memo, ifnotfound = list(-Inf))$valPrev
  valDelta <- mget('valDelta', envir = memo, ifnotfound = list(NA))$valDelta
  parMemo <- mget('par', envir = memo, ifnotfound = list(NULL))$par

  assign("count", countMemo + 1, pos = memo)

  val <- f(par)

  # if the returned val higher than the current max-value, store this val:
  if(valMemo < val) {
    assign('par', par, pos = memo)
    assign('val', val, pos = memo)
    assign('valDelta', val - valMemo, pos = memo)

    if(verbose) {
      cat('\nCall ', countMemo, ': value on par=(',
          toString(round(par, 6)), "): ", val, "\n", sep = "")
    }
  }

  # store the returned val in memo
  assign('valPrev', val, pos = memo)

  val
}


#' Calling optim a number of times
#' @inheritParams PCMFit
#' @param parLower,parUpper numeric vectors of equal length p: the number of
#' parameters of the function lik;
#' @param matParInit a numeric matrix of p columns.
#' @param control a list passed to optim().
#' @param doParallel logical indicating if optim calls should be executed in
#' parallel using the \code{foreach() \%dopar\% {}} construct. Default: FALSE.
#' @param verbose logical indicating whether informative messages should be
#' printed on the console during the run.
#'
#' @return a named list
#' @seealso \code{\link{configOptim}}.
#'
#' @importFrom stats optim
#' @importFrom foreach foreach %do% %dopar%
#' @import data.table
runOptim <- function(
  X, tree, model, SE, metaI, positiveValueGuard,
  parLower,
  parUpper,
  matParInit,
  control = NULL,
  doParallel = FALSE,
  verbose = TRUE) {

  res <- list(Optim = NULL)
  class(res) <- "ResultOptim"

  if(!(is.vector(parLower) && is.vector(parUpper) &&
       length(parLower) == length(parUpper) &&
       length(parLower) > 0 &&
       ncol(matParInit) == length(parLower))) {
    stop(
      paste(
        "parLower, parUpper should be numeric vectors of non-zero length, p;",
        " matParInit should be a numeric columns with p columns."))
  }

  if(!isTRUE(all(parLower < parUpper))) {
    stop("All elements of parLower should be smaller than the corresponding elements in parUpper.")
  }

  `%op%` <- if(isTRUE(doParallel) ||
     (is.numeric(doParallel) && doParallel > 1)) {
    `%dopar%`
  } else {
    `%do%`
  }

  listCallsOptim <- foreach(iOptimTry = seq_len(nrow(matParInit))) %op% {
    memoMaxLoglik <- new.env()

    lik <- PCMCreateLikelihood(
      X = X, tree = tree, model = model, SE = SE,
      metaI = if(is.function(metaI)) {
        metaI(X = X, tree = tree, model = model, SE = SE)
      } else {
        metaI
      },
      positiveValueGuard = positiveValueGuard)

    fnForOptim <- function(par) {
      memoiseMax(lik, par = par, memoMaxLoglik, verbose)
    }

    resIter <- list()

    resIter$parStart <- parInit <- matParInit[iOptimTry, ]
    resIter$valueStart <- fnForOptim(parInit)

    if(!(isTRUE(all(parInit >= parLower) &&
                all(parInit <= parUpper)))) {
      # this should in principle never happen, because parInit is not user-specified.
      #
      if(verbose) {
        cat(
        paste("Skipping optim try #", iOptimTry, ":",
              "All parameters in parInit should be between \n parLower=c(",
              toString(parLower), ") # and \n parUpper=c(",
              toString(parUpper), ") #, but were \n parInit = c(",
              toString(parInit), ")"))
      }
      resIter$maxPar <- parInit
      resIter$maxValue <- getOption("PCMBase.Value.NA", default = -1e+20)
      resIter$callCount <- 0L

    } else {
      if(is.null(control)) {
        control <- list()
      } else {
        control <- as.list(control)
      }

      # ensure that optim does maximization.
      control$fnscale <- -1

      if(length(parInit) > 0) {
        res.optim.call <-
          optim(fn = fnForOptim,
                par = parInit, lower = parLower, upper = parUpper,
                method = 'L-BFGS-B', control = control)

        resIter$parEnd <- res.optim.call$par
        resIter$valueEnd <- res.optim.call$value
        resIter$counts <- res.optim.call$counts
        resIter$convergence <- res.optim.call$convergence

        if(verbose) {
          cat("\nCall to optim no.", iOptimTry,
              ": starting from ",
              toString(round(parInit, 4)), ": ",
              round(resIter$valueStart, 4), "\n",
              "parLower = c(", toString(round(parLower, 4)), ")\n",
              "parUpper = c(", toString(round(parUpper, 4)), ")\n",
              "value: ", round(res.optim.call$value, 4), "\n",
              "par: ", toString(round(res.optim.call$par, 4)), "\n",
              "convergence: ", res.optim.call$convergence, "\n",
              "counts: ", toString(res.optim.call$counts), "\n",
              "message: ", toString(res.optim.call$message), "\n")
        }
      } else {
        stop("optim: parameter vector has zero length.")
      }

      resIter$maxPar <- get("par", pos = memoMaxLoglik)
      resIter$maxValue <- get("val", pos = memoMaxLoglik)
      resIter$callCount <- get("count", pos = memoMaxLoglik)
    }

    resIter
  }

  iBestCallOptim <- which.max(sapply(listCallsOptim, function(.) .$maxValue))
  res.optim <- list(
    par = listCallsOptim[[iBestCallOptim]]$maxPar,
    value = listCallsOptim[[iBestCallOptim]]$maxValue,
    count = listCallsOptim[[iBestCallOptim]]$callCount,
    listCallsOptim = listCallsOptim)

  res$Optim <- res.optim

  # tryCatch({
  # },
  # interrupt = function() {
  #   return(res)
  # },
  # error = function(e) {
  #   cat("Error in runOptim:", toString(e), "trace:")
  #   traceback()
  #   stop(e)
  # })

  res
}
