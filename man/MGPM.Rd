% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MGPM.R
\name{MGPM}
\alias{MGPM}
\title{Construct a MGPM object}
\usage{
MGPM(env, K = 0L,
  n = as.integer(sample(PCMTreeGetNodeLabels(PCMTreeEvalNestedEDxOnTree(treeEDExpr,
  get("tree", env))), K)), l = rep(0, K[[1L]]), r = n, m = rep(1L, 1L
  + length(unique(r))), v = NA_real_, treeEDExpr = "tree")
}
\arguments{
\item{env}{a \code{\link{MGPMEnvironment}} object.}

\item{K}{a single non-negative integer number denoting the number of shifts
in the model. Alternatively, this can be a double vector equal to the
concatenation of the double-converted arguments \code{K, n, l, r, m, v}. In
this case, the arguments \code{n, l, r, m, v} will be ignored. To check that
this is the case, the length of the argument K is checked for being bigger
than 1. This makes sense because the shortest possible concatenation of
\code{K, n, l, r, m, v} is of length 2. Setting this parameter to \code{NULL}
will cause it to be set at random with an integer in the range
\code{[0, M-N-1L]}, where \code{M-N-1L} is the number of internal nodes in
the tree. Default: \code{0L}.}

\item{n}{an integer vector of length \code{K} containing (integer) labels
of internal and/or tip nodes in \code{get("tree", env)} or the subtree evaluated by
\code{\link{PCMTreeEvalNestedEDxOnTree}(treeEDExpr, get("tree", env))}.
This argument is ignored if \code{length(K) > 1}. By default, or when
set to \code{NULL}, this argument will be set to
a random sample of \code{K} internal nodes of the tree obtained after
evaluating \code{treeEDExpr} on \code{get("tree", env)}. See also the argument
\code{treeEDExpr}.}

\item{l}{a double vector of length \code{K} with elements in [0,1]. Ignored if
\code{length(K) > 1}. When set to \code{NULL}, this argument will be drawn
from a uniform distribution. Default value: \code{rep(0.0, K[[1L]])}.}

\item{r}{an integer vector of length \code{(K)} containing regime names,
satisfying the rules in the description. If set to \code{NULL}, this argument is
assigned at random by respecting the rules in the description. Ignored if
\code{length(K) > 1}. Default value: \code{n}.}

\item{m}{an integer vector of length R, where R is the number of unique
regimes, specifying model type mapping for each regime. If set to \code{NULL},
this argument will be assigned at random. Ignored if
\code{length(K) > 1}. Default: \code{rep(1L, 1L + length(unique(r)))}.}

\item{v}{a double vector of length P where P is the number of variable
parameters of the MixedGaussian model corresponding to this MGPM object. If
set to \code{NULL}, this argument will be assigned at random using
the code \code{with(env, PCMParamRandomVecParams(model))}, where \code{model}
is the created \code{\link{MixedGaussian}} object corresponding to
\code{n, l, r, m, env} and \code{treeEDExpr}.
This argument will be ignored if \code{length(K) > 1}. By default this is set
to \code{NA_real_}, which results in a conversion to a vector of 0's.}

\item{treeEDExpr}{a character string (default "tree") corresponding to
a nested ED-expression for generating the MGPM object on a part of
\code{get("tree", env)}. See \code{\link{PCMTreeEvalNestedEDxOnTree}}.}
}
\value{
an object of S3 class 'MGPM'.
}
\description{
MGPM stays for Mixed Gaussian Phylogenetic Model. A MGPM object represents a
list of all variables that are subject to change during a probabilistic
inference of such a model for a given tree and trait data. By contrast, the
objects that change rarely (or not at all) during the inference, such as the
phylogetic tree, the trait data, the numerical limits for the different model
parameters, etc, are stored in a \code{\link{MGPMEnvironment}} object. By
convention, the tree in a MGPM is a \code{\link{PCMTree}} object
with node labels set to the character string representation of the corresponding
integer node ids. A \code{\link{PCMTree}} object extends the class
\code{phylo} from the R-package \code{ape} with additional fields specifying a
partition and a regime assignment (coloring) of the tree. The parts are named
as the character string labels of their corresponding root nodes. A regime,
i.e. a color, can be assigned to one or several non-neighboring parts and is
named as the corresponding part, which's name has the minimal integer value
among all parts, to which this regime is assigned.
Following this convention, a MGPM can be encoded as a numerical vector:
\deqn{\vec{s}=(K, n_2,...,n_{K+1}, l_2,...,l_{K+1}, r_2,...,r_{K+1}, m_1,...,m_R, v_1,...,v_P)^T}
The vector elements are described as follows:
\describe{
\item{\eqn{K}: }{number of shifts;}
\item{\eqn{(n_2,...,n_{K+1})^T}: }{integers representing labels of shift-nodes.
The shifts in the model occur at points within the branches leading to the
shift nodes in tip-ward direction. The corresponding locations of these
points are specified by \eqn{(l_2,...,l_{K+1})^T}.
The integers \eqn{(n_2,...,n_{K+1})^T} should be ordered in increasing order.}
\item{\eqn{(l_2,...,l_{K+1})^T}: }{offsets of the shift points measured as
fractions of the branch lengths in tip-ward direction. }
\item{\eqn{(r_2,...,r_{K+1})^T}: }{regime index vector. This is an integer
vector with elements among \eqn{(0,n_2,...,n_{K+1})^T}, indicating the
regime associated with each part in the tree. The regimes are named as the
shift nodes, except for 0, which corresponds to the root part (and regime).
The regime \eqn{r_1 = 0} is always present and, therefore,
omitted. It is possible to have lumped regimes, that is, different parts
of the tree having the same regime. This regime-lumping must obey the
following rules:
\enumerate{
\item neighbor parts cannot be lumped, i.e. they must differ by regime.
Two parts originating at nodes \eqn{n_i} and \eqn{n_j} in the tree are
called neighbor parts if they are separated solely by \eqn{n_i} or by \eqn{n_j};
\item to resolve the conflict between the shift nodes of the different parts
covered by a lumped regime, it is established that the name of a
regime assigned to several parts must equal the name of the part which is a
smaller integer number (remember that parts are named by the id's of their
root nodes, which, by convention are integer numbers).}
}
\item{\eqn{(m_1,...,m_R)^T}: }{model type assignment to the unique regimes.
This is an integer vector with elements between 1 and M, M denoting the
total number of model types possible. Each element corresponds to an
element in \code{sort(unique(c(0,r_2,...,r_{K+1})))}}
\item{\eqn{(v_1,...,v_P)^T}: }{real numbers passed to
\code{\link{PCMParamLoadOrStore}}. This is a vectorized form of the model
parameters.}
}
This function constructs a MGPM object either for the phylo object
\code{get("tree", env)} or for a subtree of this object defined by the nested
ED-expression \code{treeEDExpr}.
}
\examples{
# The PCMBase package comes with a collection of simulated objects, which we
# can use for the examples.
library(PCMBase)

tree <- PCMBaseTestObjects$tree.ab
model <-
  PCMExtractDimensions(PCMBaseTestObjects$model_MixedGaussian_ab, dims = 1:2)
X <- PCMBaseTestObjects$traits.ab.123[1:2, ]

# Create a MGPM environment
env <- MGPMEnvironment(
  X, tree,
  model = MixedGaussian(
    k = 2,
    modelTypes = MGPMDefaultModelTypes(),
    mapping = structure(1:6, names = LETTERS[1:6]),
    Sigmae_x = Args_MixedGaussian_MGPMDefaultModelTypes()$Sigmae_x))

mgpmDefault <- MGPM(env)

stopifnot(MGPMPosK(mgpmDefault) == 1L)
stopifnot(identical(MGPMPosn(mgpmDefault), integer(0)))
stopifnot(identical(MGPMPosl(mgpmDefault), integer(0)))
stopifnot(identical(MGPMPosr(mgpmDefault), integer(0)))
stopifnot(identical(MGPMPosm(mgpmDefault), 2L))
stopifnot(identical(MGPMPosv(mgpmDefault), as.integer(3:6)))

# A random MGPM
mgpmRandom <- MGPM(env, K = 6, n = NULL, l = rep(0, 6), r = NULL, m = NULL, v = NULL)
\donttest{
PCMTreePlot(
  mgpmRandom$tree) +
  ggtree::geom_nodelab(angle = 45) + ggtree::geom_tiplab(angle = 45)
}


mgpm <- MGPM(env,
  K = 4,                    # number of shifts
  n = c(8, 46, 52, 73),     # n_2, ..., n_{K+1}: shift nodes
  l = c(0, 0.4, 0.1, 0.05), # l_2, ..., l_{K+1}: offsets of the shift points
                            # relative to the beginnings of shift branches in
                            # tip-ward direction.
  r = c(0, 46, 52, 0),      # r_2,...,r_{K+1}: regime indices corresponding
                            # to the shifts. The regime of the part starting
                            # at the root node (41) is, by convention,
                            # always named 0 and is not included. The regime
                            # for the parts 8 and 73 is again 0, meaning that
                            # these regimes are lumped with the root regime.
                            # So the number of regimes are R=3, although there
                            # are 5 different parts in the tree.
  m = c(1, 5, 2)            # model type mapping for the R regimes.
                            # Note that these correspond to
                            # sort(unique(c(0, r_2, ..., r_{K+1}))).
                            # Hence, model type 1 corresponds to the
                            # single-branch regime (ending at tip 2), model
                            # type 5 correspods to the root regime (41),
                            # model type 2 corresponds to 46 and model type 3
                            # corresponds to 52.
  )

\donttest{
PCMTreePlot(
  mgpm$tree) +
  ggtree::geom_nodelab(angle = 45) + ggtree::geom_tiplab(angle = 45)
}

mgpm$n

# the names correspond to the shift nodes.
mgpm$l
mgpm$r

# The names of mgpm$m denote the regimes, while the values denote the model
# types:
mgpm$m
PCMTreeGetPartRegimes(mgpm$tree)

# This should fail because the shift nodes are not sorted in increasing order.
error <- try(
  MGPM(env, 4,
       c(8, 52, 46, 73),
       c(0, 0.1, 0.4, 0.0),
       c(0, 52, 46, 0),
       c(1, 5, 2)), silent = TRUE)
stopifnot(inherits(error, "try-error"))
mgpmVec <- as.vector(mgpm)
mgpmVec[MGPMPosv(mgpm)] <- PCMParamRandomVecParams(mgpm$model)

mgpm2 <- as.MGPM(mgpmVec, attr(mgpm, "env"))

stopifnot(identical(mgpm$n, mgpm2$n))
stopifnot(identical(mgpm$l, mgpm2$l))
stopifnot(identical(mgpm$r, mgpm2$r))
stopifnot(identical(mgpm$m, mgpm2$m))

# These two should be different values but same length:
mgpm$v
mgpm2$v

mgpm3 <- MGPM(env, c(4, 8, 46, 52, 73, 0, 0.4, 0.1, 0.05, 0, 46, 52, 0, 1, 5, 2))
stopifnot(identical(mgpm$n, mgpm3$n))
stopifnot(identical(mgpm$l, mgpm3$l))
stopifnot(identical(mgpm$r, mgpm3$r))
stopifnot(identical(mgpm$m, mgpm3$m))

mgpm4 <- MGPM(env,
  K = 1,
  n = c(62),
  l = c(0.2),
  r = c(62),
  m = c(1, 5),
  treeEDExpr = "D(E(tree,52),73)")
PCMTreeGetPartRegimes(mgpm4$tree)

\donttest{
PCMTreePlot(
  mgpm4$tree) +
  ggtree::geom_nodelab(angle = 45) + ggtree::geom_tiplab(angle = 45)
}
}
\seealso{
\code{\link{MGPMEnvironment}} \code{\link{MGPMPosK}} \code{\link{MixedGaussian}}
}
